@ExtendWith(MockitoExtension.class)
class PayrollProcessingWindowDeterminationStepTest {

    @InjectMocks
    private PayrollProcessingWindowDeterminationStep step;

    @Mock
    private HolidayService holidayService;

    @Mock
    private PayrollRepository payrollRepository;

    @Mock
    private WorkflowContext context;

    @Mock
    private GetPayrollResponse payrollResponse;

    @BeforeEach
    void setup() {
        ReflectionTestUtils.setField(step, "cutoffTimeStr", "16:00");
    }

    @Test
    void shouldPassWhenProcessingWindowIsValid() {
        String payrollId = "PR001";
        String timestamp = String.valueOf(Instant.now().getEpochSecond());
        String procDate = LocalDate.now().toString();
        String checkDate = procDate;

        when(context.get(eq("PAYROLL_ID"), eq(String.class))).thenReturn(payrollId);
        when(context.get(eq("TIMESTAMP"), eq(String.class))).thenReturn(timestamp);
        when(context.get(eq("GUSTO_SINGLE_PAYROLL"), eq(GetPayrollResponse.class))).thenReturn(payrollResponse);
        when(payrollResponse.getProcessedDate()).thenReturn(procDate);
        when(payrollResponse.getCheckDate()).thenReturn(checkDate);
        when(holidayService.isHoliday(any())).thenReturn(false);
        when(payrollRepository.findBySrcPayrollId(payrollId)).thenReturn(Optional.of(new PayrollEntity()));

        assertDoesNotThrow(() -> step.execute(context));
    }

    @Test
    void shouldFailIfCutoffTimeBreached() {
        String timestamp = String.valueOf(
                ZonedDateTime.of(LocalDate.now(), LocalTime.of(18, 0), ZoneId.systemDefault()).toEpochSecond());

        when(context.get(eq("TIMESTAMP"), eq(String.class))).thenReturn(timestamp);

        assertThrows(ProcessorException.class, () -> step.execute(context));
    }

    @Test
    void shouldFailIfProcessedDateIsHoliday() {
        String procDate = LocalDate.now().toString();

        setupDefaultContext(procDate, procDate);
        when(holidayService.isHoliday(LocalDate.parse(procDate))).thenReturn(true);

        assertThrows(ProcessorException.class, () -> step.execute(context));
    }

    @Test
    void shouldFailIfCheckDateMismatch() {
        String procDate = LocalDate.now().toString();
        String actualCheckDate = LocalDate.now().plusDays(3).toString();

        setupDefaultContext(procDate, actualCheckDate);
        when(holidayService.isHoliday(any())).thenReturn(false);

        assertThrows(ProcessorException.class, () -> step.execute(context));
    }

    @Test
    void shouldFailIfPayrollRecordMissing() {
        String procDate = LocalDate.now().toString();

        setupDefaultContext(procDate, procDate);
        when(holidayService.isHoliday(any())).thenReturn(false);
        when(payrollRepository.findBySrcPayrollId(anyString())).thenReturn(Optional.empty());

        assertThrows(ProcessorException.class, () -> step.execute(context));
    }

    private void setupDefaultContext(String procDate, String checkDate) {
        when(context.get(eq("PAYROLL_ID"), eq(String.class))).thenReturn("PR001");
        when(context.get(eq("TIMESTAMP"), eq(String.class))).thenReturn(String.valueOf(Instant.now().getEpochSecond()));
        when(context.get(eq("GUSTO_SINGLE_PAYROLL"), eq(GetPayrollResponse.class))).thenReturn(payrollResponse);
        when(payrollResponse.getProcessedDate()).thenReturn(procDate);
        when(payrollResponse.getCheckDate()).thenReturn(checkDate);
        when(payrollRepository.findBySrcPayrollId("PR001")).thenReturn(Optional.of(new PayrollEntity()));
    }
}
package net.jpmchase.payroll.processor.steps.payroll.gusto;

import net.jpmchase.payroll.processor.exception.ProcessorException;
import net.jpmchase.payroll.processor.repository.enrl.EnrollmentRepository;
import net.jpmchase.payroll.processor.service.gusto.retrieval.PayrollService;
import net.jpmchase.payroll.processor.steps.common.context.WorkflowContext;
import net.jpmchase.payroll.processor.steps.common.context.WorkflowContextUtil;
import net.jpmchase.payroll.processor.remote.gusto.model.payroll.GetPayrollResponse;
import net.jpmchase.payroll.processor.repository.enrl.entity.EnrollmentEntity;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;

import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class GustoSinglePayrollInformationRetrievalStepTest {

    private PayrollService payrollService;
    private EnrollmentRepository enrollmentRepository;
    private GustoSinglePayrollInformationRetrievalStep step;
    private WorkflowContext context;

    @BeforeEach
    void setUp() {
        payrollService = mock(PayrollService.class);
        enrollmentRepository = mock(EnrollmentRepository.class);
        context = mock(WorkflowContext.class);
        step = new GustoSinglePayrollInformationRetrievalStep(payrollService, enrollmentRepository);
    }

    @Test
    void shouldThrowIfEnrollmentIsMissing() {
        String companyId = "COMP123";
        String payrollId = "PYRL001";

        when(context.get(WorkflowContextUtil.COMPANY_UUID, String.class)).thenReturn(companyId);
        when(context.get(WorkflowContextUtil.PAYROLL_ID, String.class)).thenReturn(payrollId);
        when(enrollmentRepository.findRelEntPtryIdBySrcCoId(companyId)).thenReturn(Optional.empty());

        ProcessorException exception = assertThrows(ProcessorException.class, () -> step.execute(context));
        assertTrue(exception.getMessage().contains(companyId));
        verify(enrollmentRepository).findRelEntPtryIdBySrcCoId(companyId);
    }

    @Test
    void shouldRetrieveAndPutPayrollResponseIfEnrollmentFound() {
        String companyId = "COMP123";
        String payrollId = "PYRL001";
        EnrollmentEntity enrollment = new EnrollmentEntity();
        enrollment.setRelEntPtryId("ACTOR001");

        GetPayrollResponse response = new GetPayrollResponse();

        when(context.get(WorkflowContextUtil.COMPANY_UUID, String.class)).thenReturn(companyId);
        when(context.get(WorkflowContextUtil.PAYROLL_ID, String.class)).thenReturn(payrollId);
        when(enrollmentRepository.findRelEntPtryIdBySrcCoId(companyId)).thenReturn(Optional.of(enrollment));
        when(payrollService.getSinglePayroll("ACTOR001", companyId, payrollId)).thenReturn(response);

        step.execute(context);

        verify(context).put(WorkflowContextUtil.ENROLLMENT, enrollment);
        verify(context).put(WorkflowContextUtil.GUSTO_SINGLE_PAYROLL, response);
    }
}
