@ExtendWith(MockitoExtension.class)
class EventProcessorServiceTest {

    @Mock
    private WorkFlowRegistry workFlowRegistry;

    @Mock
    private Map<String, Step> stepRegistry;

    @Mock
    private ConditionRegistry conditionRegistry;

    @Mock
    private RetryScheduleService retryScheduleService;

    @InjectMocks
    private EventProcessorService eventProcessorService;

    private static final String ENTITY_TYPE = "entityA";
    private static final String EVENT_TYPE = "CREATE";

    private Event buildEvent(String entityType, String eventType) {
        MessageBody body = new MessageBody();
        body.setEventId(UUID.randomUUID());
        body.setEntityType(entityType);
        body.setEventType(eventType);

        Event event = new Event();
        event.setMessageId("msg123");
        event.setMessageBody(body);
        event.setProcessingStatus(EventStatus.PENDING);
        return event;
    }

    private StepConfig buildStepConfig(String name, boolean retry, boolean saf, String condition) {
        StepConfig step = new StepConfig();
        step.setName(name);
        step.setRetryEnabled(retry);
        step.setSafEnabled(saf);
        step.setExecuteOnCondition(condition);
        StepConfig.RetryConfig retryCfg = new StepConfig.RetryConfig();
        retryCfg.setMaxRetryCount(2);
        retryCfg.setRetryBackoffMs("100ms");
        step.setRetryConfigs(retryCfg);
        return step;
    }

    @Test
    void test_processEvent_shouldExecuteSuccessfully() {
        Event event = buildEvent(ENTITY_TYPE, EVENT_TYPE);
        StepConfig step = buildStepConfig("step1", true, true, "always");

        when(workFlowRegistry.getStepsForEvent(ENTITY_TYPE, EVENT_TYPE)).thenReturn(List.of(step));
        when(stepRegistry.get("step1")).thenReturn(context -> WorkflowContextStatus.SUCCESS);
        when(conditionRegistry.get("always")).thenReturn(ctx -> true);

        eventProcessorService.processEvent(event);

        verify(workFlowRegistry).getStepsForEvent(ENTITY_TYPE, EVENT_TYPE);
        verify(stepRegistry).get("step1");
    }

    @Test
    void test_processEvent_stepFailsAndRetriesSuccessfully() {
        Event event = buildEvent(ENTITY_TYPE, EVENT_TYPE);
        StepConfig step = buildStepConfig("retryStep", true, false, "always");

        when(workFlowRegistry.getStepsForEvent(ENTITY_TYPE, EVENT_TYPE)).thenReturn(List.of(step));
        when(conditionRegistry.get("always")).thenReturn(ctx -> true);

        Step failingStep = mock(Step.class);
        doThrow(new ProcessorException(ProcessorExceptionType.INFRA_RETRYABLE, "fail"))
                .doNothing()
                .when(failingStep).execute(any());

        when(stepRegistry.get("retryStep")).thenReturn(failingStep);

        eventProcessorService.processEvent(event);

        verify(failingStep, times(2)).execute(any());
    }

    @Test
    void test_processEvent_fatalErrorStopsProcessing() {
        Event event = buildEvent(ENTITY_TYPE, EVENT_TYPE);
        StepConfig step = buildStepConfig("fatalStep", false, false, "always");

        when(workFlowRegistry.getStepsForEvent(ENTITY_TYPE, EVENT_TYPE)).thenReturn(List.of(step));
        when(conditionRegistry.get("always")).thenReturn(ctx -> true);

        Step failingStep = mock(Step.class);
        doThrow(new ProcessorException(ProcessorExceptionType.FATAL, "hard fail"))
                .when(failingStep).execute(any());

        when(stepRegistry.get("fatalStep")).thenReturn(failingStep);

        eventProcessorService.processEvent(event);

        verify(failingStep).execute(any());
        // Could assert context status = FAILED if exposed
    }

    @Test
    void test_processEvent_skippableErrorLogsAndContinues() {
        Event event = buildEvent(ENTITY_TYPE, EVENT_TYPE);
        StepConfig step = buildStepConfig("skipStep", false, false, "always");

        when(workFlowRegistry.getStepsForEvent(ENTITY_TYPE, EVENT_TYPE)).thenReturn(List.of(step));
        when(conditionRegistry.get("always")).thenReturn(ctx -> true);

        Step skipStep = mock(Step.class);
        doThrow(new ProcessorException(ProcessorExceptionType.SKIPPABLE, "minor fail"))
                .when(skipStep).execute(any());

        when(stepRegistry.get("skipStep")).thenReturn(skipStep);

        eventProcessorService.processEvent(event);

        verify(skipStep).execute(any());
    }

    @Test
    void test_processEvent_noStepsFound() {
        Event event = buildEvent(ENTITY_TYPE, EVENT_TYPE);
        when(workFlowRegistry.getStepsForEvent(ENTITY_TYPE, EVENT_TYPE)).thenReturn(Collections.emptyList());

        eventProcessorService.processEvent(event);

        verify(workFlowRegistry).getStepsForEvent(ENTITY_TYPE, EVENT_TYPE);
    }

    @Test
    void test_processEvent_stepConditionFails_skipsExecution() {
        Event event = buildEvent(ENTITY_TYPE, EVENT_TYPE);
        StepConfig step = buildStepConfig("condStep", true, false, "customCond");

        when(workFlowRegistry.getStepsForEvent(ENTITY_TYPE, EVENT_TYPE)).thenReturn(List.of(step));
        when(conditionRegistry.get("customCond")).thenReturn(ctx -> false);

        eventProcessorService.processEvent(event);

        verify(conditionRegistry).get("customCond");
        verify(stepRegistry, never()).get(any());
    }
}