package net.jpmchase.payroll.processor.steps.payee;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.jpmchase.payroll.processor.client.gusto.PaymentConfigurationService;
import net.jpmchase.payroll.processor.constants.ContextKeys;
import net.jpmchase.payroll.processor.entity.PayeeAccountAuditEntity;
import net.jpmchase.payroll.processor.entity.PayeeAccountEntity;
import net.jpmchase.payroll.processor.enums.AccountStatus;
import net.jpmchase.payroll.processor.enums.ErrorCode;
import net.jpmchase.payroll.processor.exception.ProcessorException;
import net.jpmchase.payroll.processor.model.PaymentConfiguration;
import net.jpmchase.payroll.processor.model.Split;
import net.jpmchase.payroll.processor.model.WorkflowContext;
import net.jpmchase.payroll.processor.repository.PayeeAccountAuditRepository;
import net.jpmchase.payroll.processor.repository.PayeeAccountRepository;
import net.jpmchase.payroll.processor.step.Step;
import org.slf4j.MDC;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.util.List;
import java.util.Optional;

import static net.jpmchase.payroll.processor.constants.ContextKeys.*;

@Slf4j
@Component("PayeeAccountStatusDeactivator")
@RequiredArgsConstructor
public class PayeeAccountStatusDeactivatorStep implements Step {

    private final PayeeAccountRepository payeeAccountRepository;
    private final PayeeAccountAuditRepository payeeAccountAuditRepository;

    @Override
    @Transactional
    public void execute(WorkflowContext context) {
        String eventId = context.get(EVENT_ID, String.class);
        String messageId = context.get(MESSAGE_ID, String.class);
        String stepName = "PayeeAccountStatusDeactivator";
        String payeeId = context.get(SRC_PAYEE_ID, String.class);
        String bankAccountUUID = context.get(BANK_ACCOUNT_UUID, String.class);
        PaymentConfiguration paymentConfig = context.get(GUSTO_PAYEE_PAYMENT_CONFIGURATION, PaymentConfiguration.class);
        List<Split> splits = Optional.ofNullable(paymentConfig.getSplits()).orElse(List.of());

        // Set MDC
        MDC.put("eventId", eventId);
        MDC.put("messageId", messageId);
        MDC.put("stepName", stepName);

        log.info("[STEP] Starting PayeeAccount deactivation for eventId={}, messageId={}, payeeId={}, bankAccountUUID={}",
                eventId, messageId, payeeId, bankAccountUUID);

        validateBankAccountNotExistsInGusto(bankAccountUUID, splits);

        PayeeAccountEntity payeeAcct = payeeAccountRepository.findBySourceBankId(bankAccountUUID)
                .orElseThrow(() -> new ProcessorException(
                        ErrorCode.EMP_BANK_ACCOUNT_NOT_FOUND.getCode(),
                        ErrorCode.EMP_BANK_ACCOUNT_NOT_FOUND.formatMessage(bankAccountUUID)
                ));

        copyToAudit(payeeAcct, messageId);
        deactivateBankAccount(bankAccountUUID, payeeAcct);

        log.info("[STEP] Payee bank account deactivated successfully: payeeId={}, bankAccountUUID={}", payeeId, bankAccountUUID);
    }

    private void validateBankAccountNotExistsInGusto(String bankAccountUUID, List<Split> splits) {
        boolean exists = splits.stream()
                .map(Split::getBankAccountUUID)
                .anyMatch(uuid -> uuid != null && uuid.equalsIgnoreCase(bankAccountUUID));

        if (exists) {
            log.warn("[STEP] Bank account UUID still exists in Gusto. Marking event as failed. UUID={}", bankAccountUUID);
            throw new ProcessorException(
                    ErrorCode.BANK_ACCOUNT_EXISTS_IN_VENDOR_BUT_DEL_EVT_RECEIVED.getCode(),
                    ErrorCode.BANK_ACCOUNT_EXISTS_IN_VENDOR_BUT_DEL_EVT_RECEIVED.formatMessage(bankAccountUUID)
            );
        }
    }

    private void deactivateBankAccount(String bankAccountUUID, PayeeAccountEntity payeeAcct) {
        payeeAccountRepository.updateStatusBySrcBnkId(
                bankAccountUUID,
                AccountStatus.PENDING_CHANGE.getCode(),
                ContextKeys.EVENT_UPDATED_USERID,
                Instant.now(),
                payeeAcct.getUpdtTs()
        );
    }

    private void copyToAudit(PayeeAccountEntity source, String messageId) {
        PayeeAccountAuditEntity target = new PayeeAccountAuditEntity();

        target.setPyrPayeeAcctId(source.getPyrPayeeAcctId());
        target.setSrcPayeeId(source.getSrcPayeeId());
        target.setPyrEnrlId(source.getPyrEnrlId());
        target.setSrcCntrPmtAcctId(source.getSrcCntrPmtAcctId());
        target.setSrcBnkId(source.getSrcBnkId());
        target.setBnkNm(source.getBnkNm());
        target.setSplitTypeNm(source.getSplitTypeNm());
        target.setPyrPmtNb(source.getPyrPmtNb());
        target.setPayeeAcctStsCd(source.getPayeeAcctStsCd());
        target.setErrCd(source.getErrCd());
        target.setErrDescTx(source.getErrDescTx());
        target.setPyrDLvryTypeCd(source.getPyrDLvryTypeCd());
        target.setSrcEvtId(source.getSrcEvtId());

        target.setId(System.currentTimeMillis());
        target.setApplId(EVENT_UPDATED_USERID);
        target.setMessageId(messageId);
        target.setChnlId(CHANNEL_ID);
        target.setCreUsrId("SYSTEM");
        target.setCreTs(Instant.now());
        target.setUpdtUsrId(EVENT_UPDATED_USERID);
        target.setUpdtTs(Instant.now());

        payeeAccountAuditRepository.save(target);
        log.info("[STEP] Audit copy of PayeeAccountEntity created successfully. messageId={}", messageId);
    }
}