package net.jpmchase.payroll.processor.aspect;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.jpmchase.payroll.processor.entity.EventLogEntity;
import net.jpmchase.payroll.processor.enums.EventLogStatus;
import net.jpmchase.payroll.processor.model.Event;
import net.jpmchase.payroll.processor.repository.EventLogRepository;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.slf4j.MDC;
import org.springframework.stereotype.Component;

import java.time.Instant;

@Slf4j
@Aspect
@Component
@RequiredArgsConstructor
public class EventLogAspect {

    private final EventLogRepository eventLogRepository;

    private static final int MAX_REASON_LENGTH = 250;
    private static final String CHANNEL_ID = "SYSTEM";

    @Around("@annotation(net.jpmchase.payroll.processor.annotation.TrackStep)")
    public Object trackStepExecution(ProceedingJoinPoint joinPoint) throws Throwable {
        Object[] args = joinPoint.getArgs();
        if (args.length == 0 || !(args[0] instanceof Event)) {
            log.warn("[EVENT-LOG] Skipping logging aspect â€“ first argument is not Event");
            return joinPoint.proceed();
        }

        Event event = (Event) args[0];
        String eventId = event.getMessageBody().getEventId();
        String messageId = event.getMessageBody().getMessageId();
        String stepName = joinPoint.getSignature().getName();

        // Set MDC for traceability
        MDC.put("eventId", eventId);
        MDC.put("messageId", messageId);
        MDC.put("stepName", stepName);

        log.info("[EVENT-LOG] Tracking execution of eventId={}, step={}", eventId, stepName);
        updateEventLog(event, stepName, EventLogStatus.IN_PROCESS.getCode(), null);

        try {
            Object result = joinPoint.proceed();

            updateEventLog(event, stepName, EventLogStatus.COMPLETED.getCode(), null);
            log.info("[EVENT-LOG] Step completed: eventId={}, step={}", eventId, stepName);
            return result;

        } catch (Throwable t) {
            log.error("[EVENT-LOG] Step failed: eventId={}, step={}, reason={}", eventId, stepName, t.getMessage(), t);
            updateEventLog(event, stepName, EventLogStatus.FAILED.getCode(), t.getMessage());
            throw t;
        } finally {
            MDC.clear();
        }
    }

    private void updateEventLog(Event event, String stepName, String status, String failureReason) {
        EventLogEntity existingLog = eventLogRepository.findBySrcEvtId(event.getMessageBody().getEventId())
                .orElse(null);

        if (existingLog == null) {
            log.warn("[EVENT-LOG] No event log found for eventId={}", event.getMessageBody().getEventId());
            return;
        }

        String truncatedReason = failureReason != null
                ? failureReason.substring(0, Math.min(MAX_REASON_LENGTH, failureReason.length()))
                : null;

        eventLogRepository.updateStatusById(
                existingLog.getEventLogId(),
                status,
                truncatedReason,
                CHANNEL_ID,
                Instant.now()
        );

        log.info("[EVENT-LOG] Updated eventLog: eventId={}, step={}, status={}, reason={}",
                event.getMessageBody().getEventId(),
                stepName,
                status,
                truncatedReason);
    }
}