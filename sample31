import net.jpmchase.payroll.processor.service.*;
import net.jpmchase.payroll.processor.steps.*;
import net.jpmchase.payroll.processor.context.WorkflowContext;
import net.jpmchase.payroll.processor.exception.*;
import net.jpmchase.payroll.processor.model.*;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.MockitoAnnotations;

import java.math.BigDecimal;
import java.util.*;

import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

public class ReconcileEmployeePaymentInformationStepTest {

    private ReconcileEmployeePaymentService reconcileService;
    private PaymentConfigurationService paymentConfigurationService;
    private WorkflowContext context;

    private ReconcileEmployeePaymentInformationStep step;

    @BeforeEach
    public void setup() {
        reconcileService = mock(ReconcileEmployeePaymentService.class);
        paymentConfigurationService = mock(PaymentConfigurationService.class);
        context = mock(WorkflowContext.class);
        step = new ReconcileEmployeePaymentInformationStep(reconcileService, paymentConfigurationService);
    }

    @Test
    public void testExecute_shouldSkipStepWhenNoCompensations() {
        GetPayrollResponse payrollResponse = mock(GetPayrollResponse.class);
        when(context.get(eq("GUSTO_SINGLE_PAYROLL"), eq(GetPayrollResponse.class))).thenReturn(payrollResponse);
        when(payrollResponse.getEmployeeCompensations()).thenReturn(null);

        step.execute(context);

        verify(reconcileService, never()).reconcile(any(), any(), any());
    }

    @Test
    public void testExecute_shouldThrowBusinessValidationExceptionWhenNoPaymentConfig() {
        GetPayrollResponse payrollResponse = mock(GetPayrollResponse.class);
        EnrollmentEntity enrollmentEntity = mock(EnrollmentEntity.class);

        EmployeeCompensation comp = new EmployeeCompensation();
        comp.setEmployeeId("emp123");
        comp.setCheckAmount(BigDecimal.TEN);

        when(context.get(eq("GUSTO_SINGLE_PAYROLL"), eq(GetPayrollResponse.class))).thenReturn(payrollResponse);
        when(context.get(eq("COMPANY_ENROLLMENT"), eq(EnrollmentEntity.class))).thenReturn(enrollmentEntity);
        when(context.get(eq("PYRL_UUID"), eq(String.class))).thenReturn("pyrl1");
        when(context.get(eq("COMPANY_UUID"), eq(String.class))).thenReturn("company1");

        when(payrollResponse.getEmployeeCompensations()).thenReturn(List.of(comp));
        when(paymentConfigurationService.getAllEmployeePaymentConfigurationsForAPayroll(any(), any())).thenReturn(List.of());

        ProcessorException ex = assertThrows(ProcessorException.class, () -> step.execute(context));
        assertEquals(ProcessorExceptionType.BUSINESS_VALIDATION, ex.getType());
    }

    @Test
    public void testExecute_shouldReconcileSuccessfully() {
        GetPayrollResponse payrollResponse = mock(GetPayrollResponse.class);
        EnrollmentEntity enrollmentEntity = mock(EnrollmentEntity.class);

        EmployeeCompensation comp = new EmployeeCompensation();
        comp.setEmployeeId("emp123");
        comp.setCheckAmount(BigDecimal.TEN);

        EmployeePaymentConfiguration config = new EmployeePaymentConfiguration();
        config.setEmployeeId("emp123");

        when(context.get(eq("GUSTO_SINGLE_PAYROLL"), eq(GetPayrollResponse.class))).thenReturn(payrollResponse);
        when(context.get(eq("COMPANY_ENROLLMENT"), eq(EnrollmentEntity.class))).thenReturn(enrollmentEntity);
        when(context.get(eq("PYRL_UUID"), eq(String.class))).thenReturn("pyrl1");
        when(context.get(eq("COMPANY_UUID"), eq(String.class))).thenReturn("company1");

        when(payrollResponse.getEmployeeCompensations()).thenReturn(List.of(comp));
        when(paymentConfigurationService.getAllEmployeePaymentConfigurationsForAPayroll(any(), any()))
            .thenReturn(List.of(config));

        step.execute(context);

        verify(reconcileService).reconcile(eq(comp), eq(config), eq(context));
    }

    @Test
    public void testExecute_shouldPutConfigsInContext() {
        GetPayrollResponse payrollResponse = mock(GetPayrollResponse.class);
        EnrollmentEntity enrollmentEntity = mock(EnrollmentEntity.class);

        EmployeeCompensation comp = new EmployeeCompensation();
        comp.setEmployeeId("emp123");
        comp.setCheckAmount(BigDecimal.TEN);

        EmployeePaymentConfiguration config = new EmployeePaymentConfiguration();
        config.setEmployeeId("emp123");

        when(context.get(eq("GUSTO_SINGLE_PAYROLL"), eq(GetPayrollResponse.class))).thenReturn(payrollResponse);
        when(context.get(eq("COMPANY_ENROLLMENT"), eq(EnrollmentEntity.class))).thenReturn(enrollmentEntity);
        when(context.get(eq("PYRL_UUID"), eq(String.class))).thenReturn("pyrl1");
        when(context.get(eq("COMPANY_UUID"), eq(String.class))).thenReturn("company1");

        when(payrollResponse.getEmployeeCompensations()).thenReturn(List.of(comp));
        when(paymentConfigurationService.getAllEmployeePaymentConfigurationsForAPayroll(any(), any()))
            .thenReturn(List.of(config));

        step.execute(context);

        verify(context).putDeClonedList(eq("PAYROLL_EMP_CONFIGURATIONS"), eq(List.of(config)), eq(EmployeePaymentConfiguration.class));
    }

    @Test
    public void testExecute_shouldLogAndReturnWhenConditionIsFalse() {
        when(context.get(eq("CANCEL_GUSTO_PAYROLL"), eq(Boolean.class))).thenReturn(true);

        step.execute(context);

        verifyNoInteractions(paymentConfigurationService);
        verifyNoInteractions(reconcileService);
    }
}
public void publishNewAccountsToSBP(
        final List<Account> sbpAccounts,
        final Long profileId,
        final PayeeEntity payeeEntity,
        final Map<String, PayeeAccountEntity> payeeAccountUpdatedMap) {

    if (CollectionUtils.isEmpty(sbpAccounts)) return;

    counterpartyService.addAccountsToACounterparty(profileId, payeeEntity.getCntrpId(), sbpAccounts)
        .onSuccess(counterpartyAddResponse -> handleCounterpartyAddSuccess(
            counterpartyAddResponse, profileId, payeeEntity, sbpAccounts, payeeAccountUpdatedMap))
        .onFailure(error -> {
            throw ProcessorException.of(
                ProcessorExceptionType.INFRA_RETRYABLE,
                PUBLISH_PAYEE_ACCOUNT_TO_SBP_FAILED.getCode(),
                PUBLISH_PAYEE_ACCOUNT_TO_SBP_FAILED.getMessage()
            );
        });
}

private void handleCounterpartyAddSuccess(
        CounterpartyAddResponse response,
        Long profileId,
        PayeeEntity payeeEntity,
        List<Account> sbpAccounts,
        Map<String, PayeeAccountEntity> payeeAccountUpdatedMap) {

    Optional<CounterpartyError> errorOpt = Optional.ofNullable(response.getError());
    errorOpt.ifPresent(error -> log.error(
        "Counterparty ID {} with profileId {} failed to add accounts: {}",
        payeeEntity.getCntrpId(), profileId, error.getMessage()
    ));

    List<PayeeAccountEntity> updatedAccounts = new ArrayList<>();

    for (Account account : sbpAccounts) {
        String acctId = account.getCounterIdentifier();
        Optional<PayeeAccountEntity> payeeAcctOpt = Optional.ofNullable(payeeAccountUpdatedMap.get(acctId));

        payeeAcctOpt.ifPresent(payeeAcct -> {
            Optional<String> partnerAccountIdOpt = Optional.ofNullable(response.getAccountToPartnerAccountMap().get(acctId));
            partnerAccountIdOpt.ifPresent(payeeAcct::setPrtnrAcctId);
            updatedAccounts.add(payeeAcct);
        });
    }

    if (!updatedAccounts.isEmpty()) {
        payeeAccountPersistenceService.saveAndFlushAllWithAudit(updatedAccounts);
    }
}
